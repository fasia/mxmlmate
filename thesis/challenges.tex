%###
\subsection{Challenges}
%###
Getting away from pure \java and adding support for application binaries as test subjects 
to \xmlmate by transforming it from 
a single \java application into a set of loosely coupled, yet interdependent and distinct 
processes written in different programming languages presented a number of challenges from 
such fields like software engineering and system architecture design. 
In the following sections I would like to shed some light onto 
the most noteworthy of them.
%###
\subsubsection{Chromosome Representation}
%###
\label{sec:repr}
\xmlmate is implemented on top of the genetic algorithm framework that is part of 
\evosuite\cite{6004309} and as such must adhere to its specifications and structures 
of genetic representations. 
Because \evosuite as a whole is aimed at generating {\small JUnit} tests for \java applications, 
the entities that comprise the population  (i.e. the \emph{chromosomes} or \emph{individuals}) 
are called \emph{test suites}. The test suites are what evolves from generation to generation.
In turn, the test suites consist of \emph{tests}. Similarly, \xmlmate has adopted the concepts of 
test suite and test they correspond to a set of \xml trees and a single \xml tree, respectively. 
They are sometimes referred to as \emph{test suite chromosomes} and \emph{test chromosomes}, resp.


In \xmlmate all \xml trees are governed by a single \xsd that is given as a parameter at program start.
In order to implement the genetic operation \emph{mutation} for test chromosomes more or less 
efficiently each node in a test's \xml tree should have a reference to its corresponding definition 
in the schema. This is accomplished by extending some of the \java classes provided by \xom to include the 
references in question as well as methods that maintain their relevance and correctness. This alone, 
however, is not sufficient for implementing an effective \emph{crossover} of two \xml trees.

To quickly find sites suitable for crossover in two test chromosomes an additional mapping is needed: 
one that maps definitions in the global schema to nodes that are actually present in the \xml tree, so 
as to be able to find compatible intersections.
Since I am using \xerces for storing and accessing the schema information, and it is only exposed via 
a \java interface, it was not possible to add this mapping to local copies of the schema  
enhanced with the needed references to test chromosomes. However, what could be added were local 
maps referencing the global definition instances as keys and local nodes as values. A disadvantage 
is that additional methods had to be added to ensure the relevance of these mappings, 
as the node composition of an \xml tree is constantly changing. 
One benefit of this approach is the reduced memory consumption as the schema
definition must only be stored once globally, and the local mappings are nothing but sets of references 
internally and thus very lightweight.
\improvement[inline]{Add a picture of chromosome representation}
%### 
\subsubsection{Communication Protocol}
%###
Since \xmlmate now comprises several processes, a communication protocol must be put in place to 
interconnect the individual components. The communication channels themselves are built on top of
the \zmq messaging library with \msgpack as the serialization/deserialization engine. The current
implementation uses tcp loopback\footnote{TCP loopback is used because the pure \java implementation 
of \zmq does not support \texttt{ipc} on the Windows platform, which I do most of the development on.
Using a JNI based Java wrapper as a drop-in replacement would alleviate this problem, 
but it is not considered to be worth the effort.} 
as a carrier for the messages; however, it is entirely possible
to change this to inter-process communication just by changing a configuration option, should it 
become necessary. As yet, it is very far from being a bottleneck.


After each evolution step a test suite usually contains several tests that changed due to mutation and
crossover. When the fitness of the suite is requested to be computed next time by the genetic algorithm, 
only the tests that changed should be evaluated. For each of those a file is written and a packet is 
formed consisting of a number identifying the test inside the test suite and the path to its corresponding 
file. This packet is serialized into a byte string with \msgpack and then sent as a \zmq message via a 
\texttt{PUSH} socket on a well known port (e.g. the default is 5556). After all messages have been sent,
a response is awaited for each of those sent out tasks. Responses are collected as \zmq messages coming 
in via a \texttt{PULL} socket on another well known port (default 5557) and deserialized with \msgpack 
into the identifying number and whatever data format is expected by the current fitness function. 
(E.g. a fitness function that counts the number of executed basic blocks expects an array of addresses.)
As far as the \java part of \xmlmate is concerned this is all it ever sees of the entire process.
% optimizations in caching results (e.g. Trove)
% staring synchronization
\change[inline]{make pretty communication graph}
%###
\subsubsection{Format Converters}
%###
%###
\subsubsection{Parallelization}
%###
% profiling tools
% search for bottleneck
% unexpected places: 
% 	datatype optimizations
% 	random generator
% copy-on-maybe-write cloning optimization
%###
\subsubsection{Local Search}
%###